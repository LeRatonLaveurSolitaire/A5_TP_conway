//
// Generated by NVIDIA NVVM Compiler  // autogenerated header
//
// Compiler Build ID: CL-32267302        // compiler build identifier
// Cuda compilation tools, release 12.0, V12.0.140   // CUDA tools version
// Based on NVVM 7.0.1                    // NVVM version
//

// SERT A OBSERVER
// MEILLEUR KERNEL

.version 8.0                           // PTX version 8.0
.target sm_52                          // target architecture sm_52
.address_size 64                       // 64-bit addressing

	// .globl	_Z19game_of_life_kernelPhS_ss   // global symbol (commented out)

.visible .entry _Z19game_of_life_kernelPhS_ss(   // kernel entry point
	.param .u64 _Z19game_of_life_kernelPhS_ss_param_0,   // parameter 0: pointer to first array
	.param .u64 _Z19game_of_life_kernelPhS_ss_param_1,   // parameter 1: pointer to second array
	.param .u16 _Z19game_of_life_kernelPhS_ss_param_2,   // parameter 2: width
	.param .u16 _Z19game_of_life_kernelPhS_ss_param_3    // parameter 3: height
)
{
	.reg .pred 	%p<23>;              // predicate registers
	.reg .b16 	%rs<3>;               // 16-bit registers
	.reg .b32 	%r<48>;               // 32-bit registers
	.reg .b64 	%rd<12>;              // 64-bit registers

	ld.param.u64 	%rd7, [_Z19game_of_life_kernelPhS_ss_param_0];    // load parameter 0 into %rd7
	ld.param.u64 	%rd6, [_Z19game_of_life_kernelPhS_ss_param_1];    // load parameter 1 into %rd6
	ld.param.s16 	%r3, [_Z19game_of_life_kernelPhS_ss_param_2];     // load parameter 2 (width) into %r3
	ld.param.s16 	%r22, [_Z19game_of_life_kernelPhS_ss_param_3];    // load parameter 3 (height) into %r22
	cvta.to.global.u64 	%rd1, %rd7;                     // convert address from parameter 0 to global address space
	mov.u32 	%r23, %ntid.x;                 // get number of threads in block along x
	mov.u32 	%r24, %ctaid.x;                // get block index along x
	mov.u32 	%r25, %tid.x;                  // get thread index within block along x
	mad.lo.s32 	%r1, %r24, %r23, %r25;         // compute global thread id in x: r1 = blockIdx.x * blockDim.x + threadIdx.x
	mov.u32 	%r26, %ntid.y;                 // get number of threads in block along y
	mov.u32 	%r27, %ctaid.y;                // get block index along y
	mov.u32 	%r28, %tid.y;                  // get thread index within block along y
	mad.lo.s32 	%r2, %r27, %r26, %r28;         // compute global thread id in y: r2 = blockIdx.y * blockDim.y + threadIdx.y
	setp.ne.s32 	%p2, %r1, 0;                   // set predicate p2 true if r1 != 0
	mov.u32 	%r41, 0;                     // initialize r41 to 0 (accumulator)
	setp.le.s32 	%p3, %r1, %r3;                 // p3 true if r1 <= width
	and.pred  	%p4, %p2, %p3;               // p4 = p2 and p3: valid x index (non-zero and within width)
	setp.ne.s32 	%p5, %r2, 0;                   // predicate p5 true if r2 != 0
	and.pred  	%p6, %p5, %p4;               // p6 = p5 and p4: valid x and y non-zero
	setp.le.s32 	%p7, %r2, %r22;                // p7 true if r2 <= height
	and.pred  	%p1, %p7, %p6;               // p1 = p7 and p6: overall valid indices check
	add.s32 	%r29, %r2, -1;               // r29 = r2 - 1 (y - 1)
	mad.lo.s32 	%r30, %r29, %r3, %r1;         // r30 = (r2 - 1) * width + r1 (index for the upper neighbor row)
	cvt.s64.s32 	%rd8, %r30;                  // convert index to 64-bit
	add.s64 	%rd2, %rd1, %rd8;             // compute address for the upper neighbor: base + index
	not.pred 	%p8, %p1;                    // predicate p8 = not valid index (inverse of p1)
	@%p8 bra 	$L__BB0_2;                  // if not valid, branch to label $L__BB0_2

	ld.global.u8 	%r41, [%rd2+-1];             // load left neighbor of upper row, add to accumulator r41

// load central cell of upper row : grid[width * (y - 1) + x]
$L__BB0_2:
	@%p8 bra 	$L__BB0_4;                  // if not valid, branch to $L__BB0_4

	ld.global.u8 	%r31, [%rd2];                // load central cell of upper row
	add.s32 	%r41, %r41, %r31;            // add central upper neighbor to accumulator

// load right neighbor of upper row : grid[width * (y - 1) + x + 1]
$L__BB0_4:
	@%p8 bra 	$L__BB0_6;                  // if not valid, branch to $L__BB0_6

	ld.global.u8 	%r32, [%rd2+1];              // load right neighbor of upper row
	add.s32 	%r41, %r41, %r32;            // add right neighbor to accumulator

// load left neighbor of current row : grid[width * y + x - 1]
$L__BB0_6:
	mad.lo.s32 	%r10, %r2, %r3, %r1;          // r10 = r2 * width + r1 (index for the current row)
	cvt.s64.s32 	%rd3, %r10;                  // convert current row index to 64-bit
	add.s64 	%rd4, %rd1, %rd3;             // compute address for current row cell: base + index
	@%p8 bra 	$L__BB0_10;                  // if not valid, branch to $L__BB0_10

	ld.global.u8 	%r33, [%rd4+-1];             // load left neighbor in current row
	add.s32 	%r41, %r41, %r33;            // add left neighbor to accumulator

// load central cell of current row : grid[width * y + x]
// It will never step here per the rules of the game
$L__BB0_8:
	@%p8 bra 	$L__BB0_10;                 // if not valid, branch to $L__BB0_10

	ld.global.u8 	%r34, [%rd4+1];              // load right neighbor in current row
	add.s32 	%r41, %r41, %r34;            // add right neighbor to accumulator

// load left neighbor of lower row : grid[width * (y + 1) + x - 1]
$L__BB0_10:
	add.s32 	%r35, %r10, %r3;             // r35 = current index + width (index for lower row, left neighbor)
	cvt.s64.s32 	%rd9, %r35;                  // convert to 64-bit
	add.s64 	%rd5, %rd1, %rd9;             // compute address for lower row cell: base + index offset for lower row
	@%p8 bra 	$L__BB0_12;                 // if not valid, branch to $L__BB0_12

	ld.global.u8 	%r36, [%rd5+-1];             // load left neighbor of lower row
	add.s32 	%r41, %r41, %r36;            // add left neighbor to accumulator

// load central cell of lower row : grid[width * (y + 1) + x]
$L__BB0_12:
	@%p8 bra 	$L__BB0_14;                 // if not valid, branch to $L__BB0_14

	ld.global.u8 	%r37, [%rd5];                // load central cell of lower row
	add.s32 	%r41, %r41, %r37;            // add central lower neighbor to accumulator

// load right neighbor of lower row : grid[width * (y + 1) + x + 1]
$L__BB0_14:
	@%p8 bra 	$L__BB0_16;                 // if not valid, branch to $L__BB0_16

	ld.global.u8 	%r38, [%rd5+1];              // load right neighbor of lower row
	add.s32 	%r41, %r41, %r38;            // add right neighbor to accumulator

$L__BB0_16:
	ld.global.u8 	%rs1, [%rd4];                // load current cell state from current row, center
	setp.ne.s16 	%p16, %rs1, 0;               // p16 is true if current cell is alive (non-zero)
	or.b32  	%r39, %r41, 1;              // r39 = r41 OR 1 (ensures non-zero sum)
	setp.eq.s32 	%p17, %r39, 3;              // p17 true if r39 equals 3 (exactly 3 neighbors)
	and.pred  	%p18, %p17, %p16;           // p18 true if alive cell and has 3 neighbors
	setp.eq.s16 	%p19, %rs1, 0;              // p19 true if current cell is dead (zero)
	setp.eq.s32 	%p20, %r41, 3;              // p20 true if exactly 3 neighbors
	and.pred  	%p21, %p20, %p19;           // p21 true if dead cell and has 3 neighbors (birth condition)
	or.pred  	%p22, %p18, %p21;           // p22 true if either survival or birth condition met
	selp.u16 	%rs2, 1, 0, %p22;            // select new state (%rs2 = 1 if p22 true else 0)
	cvta.to.global.u64 	%rd10, %rd6;              // convert second parameter address to global address space
	add.s64 	%rd11, %rd10, %rd3;            // compute address offset for updated cell state in output array
	st.global.u8 	[%rd11], %rs2;               // store new cell state into global memory
	ret;                                   // return from kernel

}
