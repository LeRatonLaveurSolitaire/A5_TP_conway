// PTX assembly for Game of Life kernel generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-32267302
// Cuda compilation tools, release 12.0, V12.0.140

// MEILLEUR KERNEL + UNROLL
// on remarque que le code est bien plus long

.version 8.0                   // PTX version
.target sm_52                  // Target architecture: sm_52
.address_size 64               // 64-bit addressing

.visible .entry _Z19game_of_life_kernelPhS_ss(         // Kernel entry function
	.param .u64 _Z19game_of_life_kernelPhS_ss_param_0,  // Input pointer parameter (global memory)
	.param .u64 _Z19game_of_life_kernelPhS_ss_param_1,  // Output pointer parameter (global memory)
	.param .u16 _Z19game_of_life_kernelPhS_ss_param_2,  // Grid width (or similar)
	.param .u16 _Z19game_of_life_kernelPhS_ss_param_3   // Grid height (or similar)
)
{
	.reg .pred 	%p<24>;      // Allocate 24 predicate registers
	.reg .b16 	%rs<5>;      // Allocate 5 16-bit registers
	.reg .b32 	%r<51>;      // Allocate 51 32-bit registers
	.reg .b64 	%rd<24>;     // Allocate 24 64-bit registers

	// Load kernel parameters from global memory pointers
	ld.param.u64 	%rd10, [_Z19game_of_life_kernelPhS_ss_param_0];  // Load input pointer
	ld.param.u64 	%rd9, [_Z19game_of_life_kernelPhS_ss_param_1];    // Load output pointer
	ld.param.u16 	%rs1, [_Z19game_of_life_kernelPhS_ss_param_2];    // Load grid width (or related)
	ld.param.u16 	%rs2, [_Z19game_of_life_kernelPhS_ss_param_3];    // Load grid height (or related)

	// Get thread and block indices for the X dimension
	mov.u32 	%r20, %ntid.x;           // Load block size in X (number of threads per block in x)
	mov.u32 	%r21, %ctaid.x;          // Load block index in X
	mov.u32 	%r22, %tid.x;            // Load thread index within the block in X
	mad.lo.s32 	%r1, %r21, %r20, %r22;   // Compute global thread index in X: (ctaid.x * ntid.x) + tid.x

	// Get thread and block indices for the Y dimension
	mov.u32 	%r23, %ntid.y;           // Load block size in Y
	mov.u32 	%r24, %ctaid.y;          // Load block index in Y
	mov.u32 	%r25, %tid.y;            // Load thread index within the block in Y
	mad.lo.s32 	%r2, %r24, %r23, %r25;   // Compute global thread index in Y: (ctaid.y * ntid.y) + tid.y

	// Prepare addresses for neighbor calculations:
	add.s32 	%r26, %r1, 1;            // r26 = r1 + 1 (right neighbor x-index)
	cvt.s64.s32 	%rd1, %r26;              // Convert (r1 + 1) to 64-bit
	add.s32 	%r27, %r2, -1;           // r27 = r2 - 1 (upper neighbor y-index)
	add.s32 	%r28, %r2, 1;            // r28 = r2 + 1 (lower neighbor y-index)
	cvt.s64.s32 	%rd2, %r28;              // Convert (r2 + 1) to 64-bit

	// Check boundary conditions for left and top edges
	setp.lt.s32 	%p1, %r1, 1;             // True if x-index < 1 (left boundary)
	mov.u32 	%r44, 0;                // Initialize neighbor sum accumulator to 0
	setp.lt.s32 	%p2, %r2, 1;             // True if y-index < 1 (top boundary)
	cvt.s64.s32 	%rd11, %r1;              // Convert current x-index to 64-bit
	cvt.s32.s16 	%r29, %rs1;              // Convert grid width parameter to 16-bit register
	mul.wide.s32 	%rd12, %r29, %r27;         // Calculate row offset for upper row: (grid width) * (r2 - 1)
	add.s64 	%rd13, %rd12, %rd11;        // Compute offset: (r2 - 1)*width + r1
	cvta.to.global.u64 	%rd3, %rd10;       // Convert input pointer to a global memory pointer
	add.s64 	%rd4, %rd3, %rd13;         // Compute address for upper row neighbor cell

	// If at left or top boundary, skip loading the upper left neighbor.
	or.pred  	%p3, %p1, %p2;            // p3 = true if either left or top boundary condition holds
	@%p3 bra 	$L__BB0_2;             // Branch if at boundary

	// Load neighbor from the upper left cell (r1-1, r2-1)
	ld.global.u8 	%r44, [%rd4+-1];         // Load neighbor value from (rd4 - 1) into accumulator

$L__BB0_2:
	// Load neighbor directly above (r1, r2-1) if not on the top boundary.
	setp.gt.s32 	%p4, %r2, 0;             // True if not in top row (r2 > 0)
	@%p4 bra 	$L__BB0_3;             // If true, jump to load neighbor above
	bra.uni 	$L__BB0_4;             // Else, skip to next

$L__BB0_3:
	ld.global.u8 	%r30, [%rd4];            // Load neighbor above cell
	add.s32 	%r44, %r44, %r30;        // Add neighbor above to the accumulator

$L__BB0_4:
	// Prepare to load neighbor from the upper right cell (r1+1, r2-1)
	cvt.s64.s16 	%rd5, %rs1;              // Convert grid width to 64-bit
	setp.ge.s64 	%p5, %rd1, %rd5;         // True if (r1+1) exceeds grid width boundary
	or.pred  	%p7, %p2, %p5;           // True if at the top or right boundary
	@%p7 bra 	$L__BB0_6;             // Skip loading if boundary condition met

	ld.global.u8 	%r31, [%rd4+1];          // Load neighbor from the upper right cell
	add.s32 	%r44, %r44, %r31;        // Add to the accumulator

$L__BB0_6:
	// Compute address for neighbors in the same row:
	mul.lo.s32 	%r33, %r2, %r29;         // Compute row start offset: r2 * grid width
	cvt.s64.s32 	%rd14, %r33;             // Convert row offset to 64-bit
	add.s32 	%r34, %r1, -1;           // x-index for left neighbor: r1 - 1
	cvt.s64.s32 	%rd15, %r34;             // Convert left neighbor x-index to 64-bit
	add.s64 	%rd16, %rd14, %rd15;       // Offset for left neighbor in current row: (r2*width) + (r1-1)
	add.s64 	%rd6, %rd3, %rd16;         // Global address of left neighbor in the same row

	// Load left neighbor in same row if not on left boundary.
	@%p1 bra 	$L__BB0_8;             // Skip if x-index < 1
	ld.global.u8 	%r35, [%rd6];            // Load left neighbor value
	add.s32 	%r44, %r44, %r35;        // Add left neighbor to accumulator

$L__BB0_8:
	// Load right neighbor in same row if within grid boundary.
	@%p5 bra 	$L__BB0_10;            // Skip if (r1+1) is out-of-bound
	ld.global.u8 	%r36, [%rd6+2];          // Load right neighbor value from (rd6 + 2)
	add.s32 	%r44, %r44, %r36;        // Add right neighbor to accumulator

$L__BB0_10:
	// Prepare the addresses for bottom row neighbors.
	cvt.s64.s16 	%rd7, %rs2;              // Convert grid height to 64-bit
	setp.ge.s64 	%p10, %rd2, %rd7;        // True if (r2+1) is at or beyond grid height (bottom boundary)
	mul.lo.s64 	%rd17, %rd5, %rd2;        // Compute starting offset for bottom row: (grid width) * (r2+1)
	add.s64 	%rd19, %rd17, %rd11;       // Compute address offset: (r2+1)*width + r1
	add.s64 	%rd8, %rd3, %rd19;         // Global address of bottom neighbor (middle cell)

	// Load bottom left neighbor if within bounds.
	or.pred  	%p12, %p1, %p10;          // If on left boundary or bottom boundary then skip
	@%p12 bra 	$L__BB0_12;            // Branch to skip bottom left
	ld.global.u8 	%r37, [%rd8+-1];         // Load bottom left cell value
	add.s32 	%r44, %r44, %r37;        // Add to accumulator

$L__BB0_12:
	// Load bottom neighbor if within grid bounds.
	@%p10 bra 	$L__BB0_14;            // Skip if bottom boundary reached
	ld.global.u8 	%r38, [%rd8];            // Load bottom neighbor value
	add.s32 	%r44, %r44, %r38;        // Add to accumulator

$L__BB0_14:
	// Load bottom right neighbor if within bounds.
	or.pred  	%p16, %p5, %p10;          // True if at right or bottom boundary
	@%p16 bra 	$L__BB0_16;            // Skip if condition holds
	ld.global.u8 	%r39, [%rd8+1];          // Load bottom right cell value
	add.s32 	%r44, %r44, %r39;        // Add to accumulator

$L__BB0_16:
	// Compute the global index for the current cell
	mad.lo.s32 	%r41, %r2, %r29, %r1;     // r41 = r2 * grid_width + r1
	cvt.s64.s32 	%rd20, %r41;             // Convert current cell index to 64-bit
	add.s64 	%rd21, %rd3, %rd20;        // Compute global address of current cell
	ld.global.u8 	%rs3, [%rd21];            // Load current cell value (alive/dead)

	// Decide next state based on neighbor sum and current state:
	setp.ne.s16 	%p17, %rs3, 0;            // True if current cell is alive (non-zero)
	or.b32  	%r42, %r44, 1;          // Force neighbor sum to be odd by OR-ing with 1
	setp.eq.s32 	%p18, %r42, 3;          // True if (neighbor sum | 1) equals 3
	and.pred  	%p19, %p18, %p17;         // Next state remains alive if cell is alive and condition met
	setp.eq.s16 	%p20, %rs3, 0;            // True if current cell is dead
	setp.eq.s32 	%p21, %r44, 3;          // True if neighbor sum equals 3
	and.pred  	%p22, %p21, %p20;         // Next state becomes alive if cell is dead and exactly three neighbors are alive
	or.pred  	%p23, %p19, %p22;         // Combine conditions: cell lives if either predicate is true
	selp.u16 	%rs4, 1, 0, %p23;         // Select 1 (alive) if condition true, else 0 (dead)

	// Write the computed next state back to output global memory
	cvta.to.global.u64 	%rd22, %rd9;         // Convert output pointer to global pointer
	add.s64 	%rd23, %rd22, %rd20;       // Compute output address using current cell offset
	st.global.u8 	[%rd23], %rs4;           // Store next state (byte) into output memory
	ret;                            // Return from kernel
}
